From 3fdf3076dc757fdabf5ed7cd1f308ea614cd8fa8 Mon Sep 17 00:00:00 2001
From: Matteo Battaggia <matteo.battaggia@spacetest.com>
Date: Wed, 29 Apr 2015 15:40:03 +0200
Subject: [PATCH] U-Boot must raise the "TON" pin as soon as possible.

---
 board/engicam/mx6_icore/mx6_icore.c |  316 +++++++++++++++++++++++------------
 common/hush.c                       |    6 +-
 common/main.c                       |   12 +-
 drivers/video/cfb_console.c         |    2 +-
 include/configs/mx6_icore_common.h  |   36 ++--
 5 files changed, 238 insertions(+), 134 deletions(-)

diff --git a/board/engicam/mx6_icore/mx6_icore.c b/board/engicam/mx6_icore/mx6_icore.c
index 476e2eb..108d203 100644
--- a/board/engicam/mx6_icore/mx6_icore.c
+++ b/board/engicam/mx6_icore/mx6_icore.c
@@ -623,52 +623,50 @@ static struct display_info_t const displays[] = {{
 
 int board_video_skip(void)
 {
-	return -1; // MOD-MB-20150427
+	int i;
+	int ret;
+	char const *panel = getenv("lcd_panel");
+
+	if (!panel) {
+		for (i = 0; i < ARRAY_SIZE(displays); i++) {
+			struct display_info_t const *dev = displays+i;
+			if (dev->detect && dev->detect(dev)) {
+				panel = dev->mode.name;
+				printf("auto-detected panel %s\n", panel);
+				break;
+			}
+		}
+		if (!panel) {
+			panel = displays[0].mode.name;
+			printf("No panel detected: default to %s\n", panel);
+			i = 0;
+		}
+	} else {
+		for (i = 0; i < ARRAY_SIZE(displays); i++) {
+			if (!strcmp(panel, displays[i].mode.name))
+				break;
+		}
+	}
 
-//	int i;
-//	int ret;
-//	char const *panel = getenv("lcd_panel");
-//
-//	if (!panel) {
-//		for (i = 0; i < ARRAY_SIZE(displays); i++) {
-//			struct display_info_t const *dev = displays+i;
-//			if (dev->detect && dev->detect(dev)) {
-//				panel = dev->mode.name;
-//				printf("auto-detected panel %s\n", panel);
-//				break;
-//			}
-//		}
-//		if (!panel) {
-//			panel = displays[0].mode.name;
-//			printf("No panel detected: default to %s\n", panel);
-//			i = 0;
-//		}
-//	} else {
-//		for (i = 0; i < ARRAY_SIZE(displays); i++) {
-//			if (!strcmp(panel, displays[i].mode.name))
-//				break;
-//		}
-//	}
-//
-//	if (i < ARRAY_SIZE(displays)) {
-//		ret = ipuv3_fb_init(&displays[i].mode, 0,
-//				    displays[i].pixfmt);
-//		if (!ret) {
-//			if (displays[i].enable)
-//				displays[i].enable(displays+i);
-//			printf("Display: %s (%ux%u)\n",
-//			       displays[i].mode.name,
-//			       displays[i].mode.xres,
-//			       displays[i].mode.yres);
-//		} else
-//			printf("LCD %s cannot be configured: %d\n",
-//			       displays[i].mode.name, ret);
-//	} else {
-//		printf("unsupported panel %s\n", panel);
-//		return -EINVAL;
-//	}
-//
-//	return 0;
+	if (i < ARRAY_SIZE(displays)) {
+		ret = ipuv3_fb_init(&displays[i].mode, 0,
+				    displays[i].pixfmt);
+		if (!ret) {
+			if (displays[i].enable)
+				displays[i].enable(displays+i);
+			printf("Display: %s (%ux%u)\n",
+			       displays[i].mode.name,
+			       displays[i].mode.xres,
+			       displays[i].mode.yres);
+		} else
+			printf("LCD %s cannot be configured: %d\n",
+			       displays[i].mode.name, ret);
+	} else {
+		printf("unsupported panel %s\n", panel);
+		return -EINVAL;
+	}
+
+	return 0;
 }
 
 #define RGB_BACKLIGHT_REVB 	IMX_GPIO_NR(4, 20)
@@ -681,76 +679,70 @@ iomux_v3_cfg_t const backlight_pads[] = {
 
 void board_set_backlight (int status)
 {
-	return; // MOD-MB-20150427
-
-//	gpio_direction_output(RGB_BACKLIGHT_GP,   status);
-//	gpio_direction_output(RGB_BACKLIGHT_REVB, status);
+	gpio_direction_output(RGB_BACKLIGHT_GP,   status);
+	gpio_direction_output(RGB_BACKLIGHT_REVB, status);
 }
 
 static void setup_iomux_backlight(void)
 {
-	return; // MOD-MB-20150427
-
-//	imx_iomux_v3_setup_multiple_pads(backlight_pads,
-//					 ARRAY_SIZE(backlight_pads));
+	imx_iomux_v3_setup_multiple_pads(backlight_pads,
+					 ARRAY_SIZE(backlight_pads));
 }
 
 static void setup_display(void)
 {
-	return; // MOD-MB-20150427
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	struct anatop_regs *anatop = (struct anatop_regs *)ANATOP_BASE_ADDR;
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+	int reg;
+
+	setup_iomux_backlight();
+	board_set_backlight(1);
+	enable_ipu_clock();
+	imx_setup_hdmi();
+
+	/* Turn on LDB0,IPU,IPU DI0 clocks */
+	reg = __raw_readl(&mxc_ccm->CCGR3);
+	reg |=  (MXC_CCM_CCGR3_LDB_DI0_MASK | 0xffff); //TBD MM MP:
+	writel(reg, &mxc_ccm->CCGR3);
+
+	/* set PFD1_FRAC to 0x13 == 455 MHz (480*18)/0x13 */
+	writel(ANATOP_PFD_480_PFD1_FRAC_MASK, &anatop->pfd_480_clr);
+	writel(0x13<<ANATOP_PFD_480_PFD1_FRAC_SHIFT, &anatop->pfd_480_set);
+
+	/* set LDB0, LDB1 clk select to 011/011 */
+	reg = readl(&mxc_ccm->cs2cdr);
+	reg &= ~(MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_MASK
+		 |MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_MASK);
+	reg |= (3<<MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_OFFSET)
+	      |(3<<MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_OFFSET);
+	writel(reg, &mxc_ccm->cs2cdr);
+
+	reg = readl(&mxc_ccm->cscmr2);
+	reg |= MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV;
+	writel(reg, &mxc_ccm->cscmr2);
+
+	reg = readl(&mxc_ccm->chsccdr);
+	reg |= (CHSCCDR_CLK_SEL_LDB_DI0
+		<<MXC_CCM_CHSCCDR_IPU1_DI0_CLK_SEL_OFFSET);
+	writel(reg, &mxc_ccm->chsccdr);
+
+	reg = IOMUXC_GPR2_BGREF_RRMODE_EXTERNAL_RES
+	     |IOMUXC_GPR2_DI1_VS_POLARITY_ACTIVE_HIGH
+	     |IOMUXC_GPR2_DI0_VS_POLARITY_ACTIVE_LOW
+	     |IOMUXC_GPR2_BIT_MAPPING_CH1_SPWG
+	     |IOMUXC_GPR2_DATA_WIDTH_CH1_18BIT
+	     |IOMUXC_GPR2_BIT_MAPPING_CH0_SPWG
+	     |IOMUXC_GPR2_DATA_WIDTH_CH0_18BIT
+	     |IOMUXC_GPR2_LVDS_CH1_MODE_DISABLED
+	     |IOMUXC_GPR2_LVDS_CH0_MODE_ENABLED_DI0;
+	writel(reg, &iomux->gpr[2]);
 
-//	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
-//	struct anatop_regs *anatop = (struct anatop_regs *)ANATOP_BASE_ADDR;
-//	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
-//	int reg;
-//
-//	setup_iomux_backlight();
-//	board_set_backlight(1);
-//	enable_ipu_clock();
-//	imx_setup_hdmi();
-//
-//	/* Turn on LDB0,IPU,IPU DI0 clocks */
-//	reg = __raw_readl(&mxc_ccm->CCGR3);
-//	reg |=  (MXC_CCM_CCGR3_LDB_DI0_MASK | 0xffff); //TBD MM MP:
-//	writel(reg, &mxc_ccm->CCGR3);
-//
-//	/* set PFD1_FRAC to 0x13 == 455 MHz (480*18)/0x13 */
-//	writel(ANATOP_PFD_480_PFD1_FRAC_MASK, &anatop->pfd_480_clr);
-//	writel(0x13<<ANATOP_PFD_480_PFD1_FRAC_SHIFT, &anatop->pfd_480_set);
-//
-//	/* set LDB0, LDB1 clk select to 011/011 */
-//	reg = readl(&mxc_ccm->cs2cdr);
-//	reg &= ~(MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_MASK
-//		 |MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_MASK);
-//	reg |= (3<<MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_OFFSET)
-//	      |(3<<MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_OFFSET);
-//	writel(reg, &mxc_ccm->cs2cdr);
-//
-//	reg = readl(&mxc_ccm->cscmr2);
-//	reg |= MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV;
-//	writel(reg, &mxc_ccm->cscmr2);
-//
-//	reg = readl(&mxc_ccm->chsccdr);
-//	reg |= (CHSCCDR_CLK_SEL_LDB_DI0
-//		<<MXC_CCM_CHSCCDR_IPU1_DI0_CLK_SEL_OFFSET);
-//	writel(reg, &mxc_ccm->chsccdr);
-//
-//	reg = IOMUXC_GPR2_BGREF_RRMODE_EXTERNAL_RES
-//	     |IOMUXC_GPR2_DI1_VS_POLARITY_ACTIVE_HIGH
-//	     |IOMUXC_GPR2_DI0_VS_POLARITY_ACTIVE_LOW
-//	     |IOMUXC_GPR2_BIT_MAPPING_CH1_SPWG
-//	     |IOMUXC_GPR2_DATA_WIDTH_CH1_18BIT
-//	     |IOMUXC_GPR2_BIT_MAPPING_CH0_SPWG
-//	     |IOMUXC_GPR2_DATA_WIDTH_CH0_18BIT
-//	     |IOMUXC_GPR2_LVDS_CH1_MODE_DISABLED
-//	     |IOMUXC_GPR2_LVDS_CH0_MODE_ENABLED_DI0;
-//	writel(reg, &iomux->gpr[2]);
-//
-//	reg = readl(&iomux->gpr[3]);
-//	reg = (reg & ~IOMUXC_GPR3_LVDS0_MUX_CTL_MASK)
-//	    | (IOMUXC_GPR3_MUX_SRC_IPU1_DI0
-//	       <<IOMUXC_GPR3_LVDS0_MUX_CTL_OFFSET);
-//	writel(reg, &iomux->gpr[3]);
+	reg = readl(&iomux->gpr[3]);
+	reg = (reg & ~IOMUXC_GPR3_LVDS0_MUX_CTL_MASK)
+	    | (IOMUXC_GPR3_MUX_SRC_IPU1_DI0
+	       <<IOMUXC_GPR3_LVDS0_MUX_CTL_OFFSET);
+	writel(reg, &iomux->gpr[3]);
 }
 #endif /* CONFIG_VIDEO_IPUV3 */
 
@@ -824,6 +816,8 @@ u32 get_board_rev(void)
 // MOD-MB-20150427 /////////////////////////////////////////////////////////////
 // BEGIN of changes for Space 20010 carrier board.
 
+// UNUSED PINS
+
 #define NOT_USED_PINS_CTRL  NO_PAD_CTRL
 
 iomux_v3_cfg_t const not_used_pins_pads[] = {
@@ -882,6 +876,104 @@ static void spc20010_setup_not_used_pins(void)
 	gpio_direction_output(SPC20010_NU13 , 0);
 }
 
+// LED's
+
+#define LED_PINS_CTRL  NO_PAD_CTRL
+
+iomux_v3_cfg_t const led_pins_pads[] = {
+	MX6_PAD_KEY_ROW4__GPIO_4_15 | MUX_PAD_CTRL(LED_PINS_CTRL), // LED10 - red
+	MX6_PAD_GPIO_4__GPIO_1_4    | MUX_PAD_CTRL(LED_PINS_CTRL), // LED20 - green
+};
+
+#define SPC20010_LED_RED    IMX_GPIO_NR(4, 15)
+#define SPC20010_LED_GREEN  IMX_GPIO_NR(1, 4)
+
+static void spc20010_setup_led_pins(void)
+{
+	imx_iomux_v3_setup_multiple_pads(led_pins_pads, ARRAY_SIZE(led_pins_pads));
+
+	gpio_direction_output(SPC20010_LED_RED  , 1);
+	gpio_direction_output(SPC20010_LED_GREEN, 0);
+}
+
+// 5-KEYS KEYPAD
+
+#define KEYPAD_PINS_CTRL  NO_PAD_CTRL
+
+iomux_v3_cfg_t const keypad_pins_pads[] = {
+	MX6_PAD_DISP0_DAT20__GPIO_5_14 | MUX_PAD_CTRL(KEYPAD_PINS_CTRL), // ITS1
+	MX6_PAD_EIM_DA7__GPIO_3_7      | MUX_PAD_CTRL(KEYPAD_PINS_CTRL), // ITS2
+	MX6_PAD_EIM_A19__GPIO_2_19     | MUX_PAD_CTRL(KEYPAD_PINS_CTRL), // ITS3
+	MX6_PAD_EIM_D16__GPIO_3_16     | MUX_PAD_CTRL(KEYPAD_PINS_CTRL), // ITS4
+	MX6_PAD_DISP0_DAT21__GPIO_5_15 | MUX_PAD_CTRL(KEYPAD_PINS_CTRL), // ITS5
+};
+
+#define SPC20010_ITS1  IMX_GPIO_NR(5, 14)
+#define SPC20010_ITS2  IMX_GPIO_NR(3,  7)
+#define SPC20010_ITS3  IMX_GPIO_NR(2, 19)
+#define SPC20010_ITS4  IMX_GPIO_NR(3, 16)
+#define SPC20010_ITS5  IMX_GPIO_NR(5, 15)
+
+static void spc20010_setup_keypad_pins(void)
+{
+	imx_iomux_v3_setup_multiple_pads(keypad_pins_pads, ARRAY_SIZE(keypad_pins_pads));
+
+	gpio_direction_input(SPC20010_ITS1);
+	gpio_direction_input(SPC20010_ITS2);
+	gpio_direction_input(SPC20010_ITS3);
+	gpio_direction_input(SPC20010_ITS4);
+	gpio_direction_input(SPC20010_ITS5);
+}
+
+// SPI SLAVE SELECTS
+
+#define SPI_SS_PINS_CTRL  NO_PAD_CTRL
+
+iomux_v3_cfg_t const spi_ss_pins_pads[] = {
+
+	MX6_PAD_DISP0_DAT23__GPIO_5_17 | MUX_PAD_CTRL(SPI_SS_PINS_CTRL), // SS1_0
+	MX6_PAD_DISP0_DAT15__GPIO_5_9  | MUX_PAD_CTRL(SPI_SS_PINS_CTRL), // SS1_1
+	MX6_PAD_KEY_ROW2__GPIO_4_11    | MUX_PAD_CTRL(SPI_SS_PINS_CTRL), // SS1_2
+	//
+	MX6_PAD_DISP0_DAT3__GPIO_4_24  | MUX_PAD_CTRL(SPI_SS_PINS_CTRL), // SS3_0
+	MX6_PAD_DISP0_DAT4__GPIO_4_25  | MUX_PAD_CTRL(SPI_SS_PINS_CTRL), // SS3_1
+	MX6_PAD_DISP0_DAT5__GPIO_4_26  | MUX_PAD_CTRL(SPI_SS_PINS_CTRL), // SS3_2
+	MX6_PAD_DISP0_DAT6__GPIO_4_27  | MUX_PAD_CTRL(SPI_SS_PINS_CTRL), // SS3_3
+
+//	MX6_PAD_DISP0_DAT23__ECSPI1_SS0 | MUX_PAD_CTRL(SPI_SS_PINS_CTRL), // SS1_0
+//	MX6_PAD_DISP0_DAT15__ECSPI1_SS1 | MUX_PAD_CTRL(SPI_SS_PINS_CTRL), // SS1_1
+//	MX6_PAD_KEY_ROW2__ECSPI1_SS2    | MUX_PAD_CTRL(SPI_SS_PINS_CTRL), // SS1_2
+//	//
+//	MX6_PAD_DISP0_DAT3__ECSPI3_SS0  | MUX_PAD_CTRL(SPI_SS_PINS_CTRL), // SS3_0
+//	MX6_PAD_DISP0_DAT4__ECSPI3_SS1  | MUX_PAD_CTRL(SPI_SS_PINS_CTRL), // SS3_1
+//	MX6_PAD_DISP0_DAT5__ECSPI3_SS2  | MUX_PAD_CTRL(SPI_SS_PINS_CTRL), // SS3_2
+//	MX6_PAD_DISP0_DAT6__ECSPI3_SS3  | MUX_PAD_CTRL(SPI_SS_PINS_CTRL), // SS3_3
+
+};
+
+#define SPC20010_SS1_0  IMX_GPIO_NR(5, 17)
+#define SPC20010_SS1_1  IMX_GPIO_NR(5,  9)
+#define SPC20010_SS1_2  IMX_GPIO_NR(4, 11)
+//
+#define SPC20010_SS3_0  IMX_GPIO_NR(4, 24)
+#define SPC20010_SS3_1  IMX_GPIO_NR(4, 25)
+#define SPC20010_SS3_2  IMX_GPIO_NR(4, 26)
+#define SPC20010_SS3_3  IMX_GPIO_NR(4, 27)
+
+static void spc20010_setup_spi_ss_pins(void)
+{
+	imx_iomux_v3_setup_multiple_pads(spi_ss_pins_pads, ARRAY_SIZE(spi_ss_pins_pads));
+
+	gpio_direction_output(SPC20010_SS1_0, 1);
+	gpio_direction_output(SPC20010_SS1_1, 1);
+	gpio_direction_output(SPC20010_SS1_2, 1);
+
+	gpio_direction_output(SPC20010_SS3_0, 1);
+	gpio_direction_output(SPC20010_SS3_1, 1);
+	gpio_direction_output(SPC20010_SS3_2, 1);
+	gpio_direction_output(SPC20010_SS3_3, 1);
+}
+
 // MOD-MB-20150427
 // END of changes for Space 20010 carrier board. ///////////////////////////////
 
@@ -891,6 +983,18 @@ int board_early_init_f(void)
 	// Changes for Space 20010 carrier board.
 	spc20010_setup_not_used_pins();
 
+	// MOD-MB-20150427
+	// Handle LED's.
+	spc20010_setup_led_pins();
+
+	// MOD-MB-20150427
+	// Handle keypad's pins.
+	spc20010_setup_keypad_pins();
+
+	// MOD-MB-20150427
+	// Handle SPI slave selects.
+	spc20010_setup_spi_ss_pins();
+
 	setup_iomux_uart();
 
 #if defined(CONFIG_VIDEO_IPUV3)
diff --git a/common/hush.c b/common/hush.c
index 61b3fe0..e34f1b0 100644
--- a/common/hush.c
+++ b/common/hush.c
@@ -3227,11 +3227,11 @@ static int parse_stream_outer(struct in_str *inp, int flag)
 	if(bFirstTime)
 		bFirstTime=false;
 	else
-		board_set_backlight(0);
+		//board_set_backlight(0);
 	#else
-	board_set_backlight(0);
+	//board_set_backlight(0);
 	#endif
-	
+
 	return (code != 0) ? 1 : 0;
 #endif /* __U_BOOT__ */
 }
diff --git a/common/main.c b/common/main.c
index 4b1df0c..6c6558a 100644
--- a/common/main.c
+++ b/common/main.c
@@ -72,7 +72,7 @@ void show_boot_progress (int val) __attribute__((weak, alias("__show_boot_progre
 #if defined(CONFIG_UPDATE_TFTP)
 int update_tftp (ulong addr);
 #endif /* CONFIG_UPDATE_TFTP */
- 
+
 //! This function show on u-boot consolle on start-up the version
 //  For setting the version open file mx25_3stack.
 void version_show(void)
@@ -124,9 +124,9 @@ int stringfind (char *str, char *key)
 void check_fec_on_bootargs(void)
 {
   	char *sBootArgs = getenv("bootargs");
-	
+
 	if ( !stringfind (sBootArgs, "fec_mac"))
-	{		
+	{
 		char *sEthAddr = getenv("ethaddr");
 		char sNewEnv[512];
 		if(sEthAddr!=NULL)
@@ -140,8 +140,8 @@ void check_fec_on_bootargs(void)
 		else
 		{
 			printf("WARNING: ***** No MAC address: set ethaddr *****\n");
-		}	
-		
+		}
+
 	}
 }
 
@@ -552,7 +552,7 @@ void main_loop (void)
 	debug ("### main_loop: bootcmd=\"%s\"\n", s ? s : "<UNDEFINED>");
 
 	if (bootdelay != -1 && s && !abortboot(bootdelay)) {
-	board_set_backlight(0);
+	//board_set_backlight(0);
 # ifdef CONFIG_AUTOBOOT_KEYED
 		int prev = disable_ctrlc(1);	/* disable Control C checking */
 # endif
diff --git a/drivers/video/cfb_console.c b/drivers/video/cfb_console.c
index 7afe492..0cf6878 100644
--- a/drivers/video/cfb_console.c
+++ b/drivers/video/cfb_console.c
@@ -1968,7 +1968,7 @@ static void *video_logo(void)
 	__maybe_unused ulong addr;
 	__maybe_unused char *s;
 
-	splash_get_pos(&video_logo_xpos, &video_logo_ypos);
+	//splash_get_pos(&video_logo_xpos, &video_logo_ypos);
 
 #ifdef CONFIG_SPLASH_SCREEN
 	s = getenv("splashimage");
diff --git a/include/configs/mx6_icore_common.h b/include/configs/mx6_icore_common.h
index a628f6f..1210eb1 100644
--- a/include/configs/mx6_icore_common.h
+++ b/include/configs/mx6_icore_common.h
@@ -368,24 +368,24 @@
 #define CONFIG_SYS_I2C_SLAVE            0x8
 
 /* Framebuffer */
-#define CONFIG_VIDEO
-#define CONFIG_VIDEO_IPUV3
-#define CONFIG_CFB_CONSOLE
-#define CONFIG_VGA_AS_SINGLE_DEVICE
-#define CONFIG_SYS_CONSOLE_IS_IN_ENV
-#define CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE
-#define CONFIG_VIDEO_BMP_RLE8
-#define CONFIG_SPLASH_SCREEN
-#define CONFIG_SPLASH_SCREEN_ALIGN
-#define CONFIG_BMP_16BPP
-#define CONFIG_VIDEO_LOGO
-#define CONFIG_VIDEO_BMP_LOGO
-#ifdef CONFIG_MX6DL
-#define CONFIG_IPUV3_CLK 198000000
-#else
-#define CONFIG_IPUV3_CLK 264000000
-#endif
-#define CONFIG_IMX_HDMI
+//#define CONFIG_VIDEO
+//#define CONFIG_VIDEO_IPUV3
+//#define CONFIG_CFB_CONSOLE
+//#define CONFIG_VGA_AS_SINGLE_DEVICE
+//#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+//#define CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE
+//#define CONFIG_VIDEO_BMP_RLE8
+//#define CONFIG_SPLASH_SCREEN
+//#define CONFIG_SPLASH_SCREEN_ALIGN
+//#define CONFIG_BMP_16BPP
+//#define CONFIG_VIDEO_LOGO
+//#define CONFIG_VIDEO_BMP_LOGO
+//#ifdef CONFIG_MX6DL
+//#define CONFIG_IPUV3_CLK 198000000
+//#else
+//#define CONFIG_IPUV3_CLK 264000000
+//#endif
+//#define CONFIG_IMX_HDMI
 
 #if defined(CONFIG_ANDROID_SUPPORT)
 #include "mx6qsabreandroid_common.h"
-- 
1.7.9.5

